# 服务端渲染 
## React.js(Next.js https://www.nextjs.cn/) Vue.js(Nuxt.js https://www.nuxtjs.cn/)
# 网络请求
 ## get与post区别
  1. get请求快一倍添加到书签中,也可以保存在浏览器历史记录中,post不能
  2. get请求可以被浏览器缓存,post不能
  3. get请求受到url长度的限制,post请求理论上不会
  4. get请求只能传输ASCII字符,而POST请求可以传输二进制数据
  5. get请求产生一个TCP数据包post请求产生两个TCP数据包
 ## 网络七层协议
  * 物理层--数据链路层--网络层(IP)--传输层(TCP)--会话层--表示层--应用层(HTTP)
 ## http
  ### http版本
   * http2->http1 多路复用,在一个TCP连接下可以发送多次HTTP请求
  ### https
   * HTTPS=HTTP+加密+认证+完整性保护
   * 通过抓包获取的数据都不是明文传输
   * 内容加密: 采用混合技术,中间者无法直接查看明文内容
   * 验证身份: 通过证书认证客户端访问的是自己的服务器
   * 保护数据完整性: 防止传输的内容被中间人冒充或者篡改
  ### 工作过程
   1. 地址解析(浏览器缓存->操作系统缓存->本地DNS->根域名DNS)
   2. 封装http请求数据包
   3. 封装成tcp包,建立连接(3次握手)
   4. 客户端发送请求
   5. 服务器响应
   6. 关闭tcp连接(4次挥手)
  ### 组成
   * 请求报文: 请求行,请求首部,空行,报文主体
   * 响应报文: 响应行,响应首部,空行,报文主体
  ### 状态码
   * 1xx: 信息，服务器收到请求，需要请求者继续执行操作
   * 2xx: 成功，操作被成功接收并处理
   * 3xx: 重定向,需要进一步操作以完成请求 (301永久重定向,302临时重定向)
   * 4xx: 请求错误,客户端发送的请求有问题 (401要求用户的身份认证,404表示请求资源不存在)
   * 5xx: 服务器错误,表示服务端在处理请求的时候发生了错误
  ### 三次握手四次挥手
   * 第一次握手: 服务器发送网络包,客户端收到了,客户端的发送能力,服务端接收能力是否正常
   * 第二次握手: 服务器发包,客户端收到了,
# js基础
 ## 渲染过程
  1. 将HTML解析成一个DOM树,一个深度遍历的过程,当所有子节点都构造好后采购构建当前节点的下一个兄弟节点
  2. 将CSS解析成CSS Rule Tree(css 规则树)
  3. 通过DOM树和CSS规则树生成渲染树
  4. 根据渲染树计算每一个节点的信息
  5. 根据计算好的信息绘制页面
 ## 性能优化
  1. 减少http请求次数(合并静态资源,js或者css代码)
  2. 使用静态CDN来存储文件
  3. 减少DOM数量
  4. 防抖与节流
  5. 事件委托
  6. 动画尽量使用css避免使用js,设置一些属性可以开启硬件加速(transfrom,opacity,filters,will-change)
  7. 减少重绘(repaint)和回流(reflow)

    * 浏览器回流必将引起重绘,重绘不一定会引起回流
    * 当页面中的元素样式改变不影响它在文档流中的位置(color,background等).浏览器会将新样式赋予给元素
      并重新绘制它,这个过程称为重绘
    * 当渲染树中部门或全部元素的尺寸,结构或某些属性发生改变时,浏览器重新渲染部分或全部文档的过程称为回流
  8. Vue相关优化

    * 引入生产环境的Vue文件
    * 使用单文件组件预编译模板
    * 提取组件的CSS到单独的文件
    * 利用Object.freeze()提升性能
    * 扁平化store数据结构
    * 合理使用持久化的store数据(vuex-persist)
    * 组件懒加载
 ## 闭包
  ### 概念
   * 闭包是有权限访问其他函数作用域内的变量的一个函数
   * 由于在js中,变量的作用域属于函数作用域,在函数执行后作用域及就会被清理,内存也随之回收,但是由于闭包是建立
     在一个函数内部的子函数,由于其可以访问上级作用域的原因,即使上级函数执行完,作用域也不会随之销毁,这时子函
     数--也就是闭包,便拥有访问上级作用域中的变量的权限,即使上级函数执行完后作用域内的值也不会被销毁
   * 产生闭包必须保证外层函数执行完毕时,内部函数的引用持续存在
  ### 场景
    * setTimeout
      ```javascript
      //setTimeout一个函数不能传递参数
      function fn(a) {
          return function() {
              console.log(a)
          }
      }
      setTimeout(fn(1), 1000);
      ```
    * 封装私有属性
      ```javascript
      //setTimeout一个函数不能传递参数
      function fn(a) {
          return function() {
              console.log(a)
          }
      }
      setTimeout(fn(1), 1000);
      ```
 ## 原型
  ### 定义
   * 构造函数是一种特殊的方法,主要用来在创建时初始化对象,每一个构造函数都有prototype(原型),指向一个对象,
     这个对象的用途是包含特定类型的所有实例共享的属性和方法,即这几个原型对象是用来给实例对象共享属性和方法的.
     每个实例对象的__proto__都指向构造函数/类的prototype
   * 
 ## 跨域
  ### 出现原因
  * 因为浏览器出于安全的考虑,对同源策略的一种实现,协议/域名/端口不一致就会出现跨域问题
  ### 解决方案
   * 修改浏览器的安全设置(不推荐)
   * JSONP
   * 跨域资源共享CORS(Cross-Origin Resource Sharing)
   * iframe(不推荐)
   * 反向代理
 ## 技巧
  ### 判断数据类型
   1. typeof 返回结果有: number,boolean,string,function,object,undefined
   2. instanceof 返回true,false
   3. Object.prototype.toString.call() (推荐使用)
   4. contructor
   5. Array.isArray() 返回true,false (判断是否为数组)

    ###
# Vue
 ## 生命周期
  * 见生命周期图
  * vue每一个组件都是独立的每个组件都有属于它的生命周期,创建-挂载-更新-销毁阶段形成了生命周期
  * 优先级顺序: render > template > el
 ## 组件间通信
  1. props/$emit
  2. $emit/$on
  3. $parent/$children与ref
  4. vuex